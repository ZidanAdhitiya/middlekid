import { NextRequest, NextResponse } from "next/server";

const ALCHEMY_API_KEY = "9a5HgXqX3Fgk-k-FugDEq";

// Prioritize chains most likely to have value
const CHAINS = {
    ethereum: `https://eth-mainnet.g.alchemy.com/v2/${ALCHEMY_API_KEY}`,
    base: `https://base-mainnet.g.alchemy.com/v2/${ALCHEMY_API_KEY}`,
    polygon: `https://polygon-mainnet.g.alchemy.com/v2/${ALCHEMY_API_KEY}`,
    arbitrum: `https://arb-mainnet.g.alchemy.com/v2/${ALCHEMY_API_KEY}`,
};

interface Token {
    contractAddress: string;
    name: string;
    symbol: string;
    decimals: number;
    balance: string;
    logo?: string;
    priceUsd?: number;
    valueUsd?: number;
    chain: string;
}

// Fetch with timeout
async function fetchWithTimeout(url: string, options: any, timeout = 10000): Promise<Response> {
    const controller = new AbortController();
    const id = setTimeout(() => controller.abort(), timeout);

    try {
        const response = await fetch(url, { ...options, signal: controller.signal });
        clearTimeout(id);
        return response;
    } catch (error) {
        clearTimeout(id);
        throw error;
    }
}

// Batch fetch token metadata
async function batchGetTokenMetadata(rpcUrl: string, tokens: any[]): Promise<any[]> {
    const results = await Promise.all(
        tokens.map(async (token) => {
            try {
                const response = await fetch(rpcUrl, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        jsonrpc: "2.0",
                        id: 1,
                        method: "alchemy_getTokenMetadata",
                        params: [token.contractAddress],
                    }),
                });

                const data = await response.json();
                return { ...token, metadata: data.result };
            } catch {
                return { ...token, metadata: null };
            }
        })
    );

    return results;
}

// Get prices using DEX Screener (best coverage for DEX-traded tokens)
async function getTokenPrices(tokens: Array<{ address: string, chain: string, symbol: string }>): Promise<Record<string, number>> {
    const prices: Record<string, number> = {};

    // Hardcoded stablecoins and major tokens
    const knownPrices: Record<string, number> = {
        'USDT': 1, 'USDC': 1, 'DAI': 1, 'USDC.e': 1, 'USDbC': 1,
        'WETH': 3000, 'WBTC': 95000,
    };

    // Apply known prices first
    for (const token of tokens) {
        const key = `${token.chain}:${token.address.toLowerCase()}`;
        if (knownPrices[token.symbol]) {
            prices[key] = knownPrices[token.symbol];
        }
    }

    // Fetch from DEX Screener for tokens without prices
    const tokensToFetch = tokens.filter(t => {
        const key = `${t.chain}:${t.address.toLowerCase()}`;
        return !prices[key];
    });

    // Batch process in chunks of 30 addresses
    for (let i = 0; i < tokensToFetch.length; i += 30) {
        const chunk = tokensToFetch.slice(i, i + 30);
        const addresses = chunk.map(t => t.address).join(',');

        try {
            const response = await fetchWithTimeout(
                `https://api.dexscreener.com/latest/dex/tokens/${addresses}`,
                { headers: { 'accept': 'application/json' } },
                10000
            );

            if (response.ok) {
                const data = await response.json();

                if (data.pairs && Array.isArray(data.pairs)) {
                    // Group pairs by token address
                    const pairsByToken: Record<string, any[]> = {};

                    for (const pair of data.pairs) {
                        if (pair.baseToken && pair.priceUsd) {
                            const addr = pair.baseToken.address.toLowerCase();
                            if (!pairsByToken[addr]) pairsByToken[addr] = [];
                            pairsByToken[addr].push(pair);
                        }
                    }

                    // For each token, use the pair with highest liquidity
                    for (const [addr, pairs] of Object.entries(pairsByToken)) {
                        // Sort by liquidity
                        pairs.sort((a, b) => (b.liquidity?.usd || 0) - (a.liquidity?.usd || 0));

                        const bestPair = pairs[0];
                        const priceUsd = parseFloat(bestPair.priceUsd);

                        if (!isNaN(priceUsd) && priceUsd > 0) {
                            // Find which chain this token belongs to
                            const token = chunk.find(t => t.address.toLowerCase() === addr);
                            if (token) {
                                const key = `${token.chain}:${addr}`;
                                prices[key] = priceUsd;
                                console.log(`Got price for ${token.symbol}: $${priceUsd}`);
                            }
                        }
                    }
                }
            }
        } catch (error) {
            console.error('DEX Screener error for chunk:', error);
        }

        // Small delay between batches to avoid rate limiting
        if (i + 30 < tokensToFetch.length) {
            await new Promise(resolve => setTimeout(resolve, 200));
        }
    }

    console.log(`Fetched prices for ${Object.keys(prices).length} out of ${tokens.length} tokens`);
    return prices;
}

// Get native prices
async function getNativePrices(): Promise<Record<string, number>> {
    try {
        const response = await fetchWithTimeout(
            'https://api.coingecko.com/api/v3/simple/price?ids=ethereum,matic-network&vs_currencies=usd',
            { headers: { 'accept': 'application/json' } },
            5000
        );

        const data = await response.json();
        const ethPrice = data.ethereum?.usd || 3000;

        return {
            ethereum: ethPrice,
            polygon: data['matic-network']?.usd || 0.8,
            base: ethPrice,
            arbitrum: ethPrice,
        };
    } catch {
        return { ethereum: 3000, polygon: 0.8, base: 3000, arbitrum: 3000 };
    }
}

export async function GET(request: NextRequest) {
    try {
        const searchParams = request.nextUrl.searchParams;
        const address = searchParams.get("address");

        if (!address) {
            return NextResponse.json(
                { error: "Wallet address is required" },
                { status: 400 }
            );
        }

        const allTokens: Token[] = [];

        // Fetch from all chains in parallel
        const chainResults = await Promise.all(
            Object.entries(CHAINS).map(async ([chainName, rpcUrl]) => {
                try {
                    // Get token balances
                    const balancesResponse = await fetchWithTimeout(rpcUrl, {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({
                            jsonrpc: "2.0",
                            id: 1,
                            method: "alchemy_getTokenBalances",
                            params: [address],
                        }),
                    }, 15000);

                    const balancesData = await balancesResponse.json();
                    if (!balancesData.result) return { chain: chainName, tokens: [], nativeBalance: BigInt(0) };

                    const tokens = balancesData.result.tokenBalances
                        .filter((token: any) => parseInt(token.tokenBalance, 16) > 0)
                        .slice(0, 100); // Increased to 100 tokens per chain

                    console.log(`${chainName}: Found ${balancesData.result.tokenBalances.length} total, ${tokens.length} with balance`);

                    // Get native balance
                    const ethBalanceResponse = await fetchWithTimeout(rpcUrl, {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({
                            jsonrpc: "2.0",
                            id: 1,
                            method: "eth_getBalance",
                            params: [address, "latest"],
                        }),
                    }, 5000);

                    const ethBalanceData = await ethBalanceResponse.json();
                    const nativeBalance = ethBalanceData.result ? BigInt(ethBalanceData.result) : BigInt(0);

                    // Batch fetch metadata
                    const tokensWithMetadata = await batchGetTokenMetadata(rpcUrl, tokens);

                    return { chain: chainName, tokens: tokensWithMetadata, nativeBalance };
                } catch (error) {
                    console.error(`Error fetching ${chainName}:`, error);
                    return { chain: chainName, tokens: [], nativeBalance: BigInt(0) };
                }
            })
        );

        // Process tokens
        for (const { chain, tokens } of chainResults) {
            for (const token of tokens) {
                if (token.metadata) {
                    allTokens.push({
                        contractAddress: token.contractAddress,
                        name: token.metadata.name || "Unknown",
                        symbol: token.metadata.symbol || "???",
                        decimals: token.metadata.decimals || 18,
                        balance: token.tokenBalance,
                        logo: token.metadata.logo,
                        chain,
                    });
                } else {
                    console.log(`${chain}: Failed to get metadata for ${token.contractAddress}`);
                }
            }
        }

        console.log(`Total tokens with metadata: ${allTokens.length}`);

        // Get prices
        const tokenPriceKeys = allTokens.map(t => ({ address: t.contractAddress, chain: t.chain, symbol: t.symbol }));
        const tokenPrices = await getTokenPrices(tokenPriceKeys);
        const nativePrices = await getNativePrices();

        // Calculate values
        const tokensWithValues = allTokens.map((token) => {
            const balanceNum = parseInt(token.balance, 16);
            const balanceDecimal = balanceNum / Math.pow(10, token.decimals);
            const priceKey = `${token.chain}:${token.contractAddress.toLowerCase()}`;
            const priceUsd = tokenPrices[priceKey] || 0;
            const valueUsd = balanceDecimal * priceUsd;

            return { ...token, priceUsd, valueUsd };
        });

        // Add native balances
        const nativeSymbols: Record<string, { symbol: string, name: string, logo: string }> = {
            ethereum: { symbol: 'ETH', name: 'Ethereum', logo: 'https://assets.coingecko.com/coins/images/279/small/ethereum.png' },
            base: { symbol: 'ETH', name: 'Ethereum (Base)', logo: 'https://assets.coingecko.com/coins/images/279/small/ethereum.png' },
            polygon: { symbol: 'POL', name: 'Polygon', logo: 'https://assets.coingecko.com/coins/images/4713/small/matic-token-icon.png' },
            arbitrum: { symbol: 'ETH', name: 'Ethereum (Arbitrum)', logo: 'https://assets.coingecko.com/coins/images/279/small/ethereum.png' },
        };

        let totalValue = tokensWithValues.reduce((sum, token) => sum + (token.valueUsd || 0), 0);

        for (const { chain, nativeBalance } of chainResults) {
            if (nativeBalance > BigInt(0)) {
                const balanceDecimal = Number(nativeBalance) / Math.pow(10, 18);
                const priceUsd = nativePrices[chain] || 0;
                const valueUsd = balanceDecimal * priceUsd;
                totalValue += valueUsd;

                const nativeInfo = nativeSymbols[chain];
                tokensWithValues.push({
                    contractAddress: "0x0000000000000000000000000000000000000000",
                    name: nativeInfo.name,
                    symbol: nativeInfo.symbol,
                    decimals: 18,
                    balance: `0x${nativeBalance.toString(16)}`,
                    logo: nativeInfo.logo,
                    priceUsd,
                    valueUsd,
                    chain,
                });
            }
        }

        // Sort by value
        tokensWithValues.sort((a, b) => (b.valueUsd || 0) - (a.valueUsd || 0));

        return NextResponse.json({
            tokens: tokensWithValues,
            totalValue: totalValue.toFixed(2)
        });
    } catch (error: any) {
        console.error("Error fetching tokens:", error);
        return NextResponse.json(
            { error: error.message || "Failed to fetch tokens" },
            { status: 500 }
        );
    }
}
